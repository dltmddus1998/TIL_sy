# 인증 & 보안 기초 개념 정리

## HTTP vs. HTTPS

#

- HTTP와 HTTPS의 차이점을 이해할 수 있다.
  - HTTP : 인터넷에서 데이터를 주고받을 수 있는 통신 프로토콜
    - 중간에 누군가가 요청을 들여다보면 요청의 내용을 그대로 볼 수 있어서 개인 정보가 쉽게 노출됨.
  - HTTPS : HTTP + Secure - HTTP 프로토콜 내용을 암호화하여 보안성 추가
    - 요청의 내용을 한번 암호화 시켜서 개인 정보가 유출되더라도 정확한 키가 없다면 어떤 내용인지 알 수 없음.
    - 인증서 (Certificate) : 서버는 인증서와 함께 응답을 전송한다.
      - 데이터 제공자 신원 보장
      - 도메인 종속
      1. 요청을 받는다면 서버는 인증서와 함께 응답을 전송한다.
      2. 응답을 받은 클라이언트는 인증서에 작성된 도메인과 응답 객체에 작성된 도메인을 비교한다.
      3. 만약에 같다면 정말로 데이터를 제공해준 서버가 확실하다는 걸 인증한다.
      4. 하지만 해커가 중간에 요청을 탈취해서 서버인척 클라이언트인척 제3자 공격이 발생한다면 같지 않아서 클라이언트에서 서버 제공자가 아닌 다른 제3자임을 알 수 있다.
    - CA
      - Certificate Authority
      - 공인 인증서 발급 기관
      - 각 브라우저는 각자 신뢰하는 CA의 정보를 가지고 있다.
      - 자격이 계속 유지되는 것이 아니라 박탈될 수도 있다.
    - 비대칭 키 암호화
      - 키 A로 암호화한 경우에는 키 B로만 복호화가 가능하다.
      - HTTPS 프로토콜을 이용하는 서버는 한 쌍의 키 중에서 하나는 비밀로 숨겨두고 다른 하나는 클라이언트로 공개해서 데이터를 안전하게 전송할 수 있게 한다.
      - 모든 통신에 대해서 공개키 방식을 사용하진 않는다. (매번 사용하기에는 알고리즘이 매우 복잡하다.)
        - 통신의 초창기에서만 비밀키를 사용하기위한 키를 만들어내기 위해 사용한다.
    - Hand Shake - 비밀 키 생성 - 상호 키 검증
      1. 서로를 확인하고 서버는 클라이언트의 공개키 한 쌍의 키 중 하나를 전달한다.
      2. 클라이언트는 전달받은 키를 이용해서 서버와 키를 만들어낼 임의의 정보를 암호화해서 전송한다.
      3. 서버는 클라이언트와 마찬가지로 임의의 정보를 암호화해서 전송한다.
      4. 클라이언트 및 서버는 서로 만들고 교환한 임의의 정보를 바탕으로 비밀키를 생성한다.
      5. 각자 생성한 키를 바탕으로 클라이언트가 텍스트용 데이터를 만들어낸 비밀키로 암호화를 해서 전달한다.
      6. 서버 역시 만들어진 비밀키로 복호화하고 다시 암호화해서 클라이언트로 전달한다.
      7. 만약 클라이언트가 같은 내용의 데이터를 복호화하는데 성공했다면 성공적으로 비밀키가 만들어지고 HTTPS 연결이 성립한 상태이다.
      8. 이후에 이 비밀키를 바탕을 데이터 송수신에 필요한 동일키 암호화 및 복호화를 진행한다.
  - 사설 인증서 발급 및 HTTPS 서버 구현
    - HTTPS가 왜 인증에서 필요하고, 왜 사용해야 하는지 이해할 수 있다.
    - 로컬 환경(localhost)에서 인증서를 생성하고, 인증서를 이용해 HTTPS 서버 만들기

#

## Cookie

#

- 쿠키의 작동 원리를 이해할 수 있다
  - Cookie : 쿠키는 서버에서 클라이언트에 데이터를 저장하는 방법 중 하나
    - 서버가 원한다면 서버는 클라이언트에서 쿠키를 이용하여 데이터를 가져올 수 있다.
      - 쿠키를 이용하는 것은 **단순히 서버에서 클라이언트에 쿠키를 전송하는 것만 의미하지 않고 클라이언트에서 서버로 쿠키를 전송하는 것도 포함된다**. (client ←→ server)
    - **서버가 클라이언트에 데이터를 저장할 수 있다.**
      - 데이터를 저장한 이후 아무 때나 데이터를 가져올 수 없다. 데이터를 저장한 후 특정 조건들이 만족하는 경우에만 다시 가져올 수 있다.
      - 위 조건들을 **쿠키 옵션**으로 표현 가능하다.
        - **Domain** - ex) [`www.google.com`](http://www.google.com)
          - 쿠키 옵션에서 도메인은 포트 및 서브 도메인 정보, 세부 경로를 제외한다.
          - 예를 들어 요청해야 할 URL이 `[http://www.localhost.com:3000/users/login](http://www.localhost.com:3000/users/login)` 이라 하면 쿠키 옵션에서 도메인은 `localhost.com` 이 된다.
          - 만약 쿠키 옵션에서 도메인 정보가 존재한다면 **클라이언트에서는 쿠키의 도메인 옵션과 서버의 도메인이 일치해야 쿠키를 전송할 수 있다.**
        - **Path** - 세부 경로는 **서버가 라우팅할 때 사용하는 경로**이다.
          - 요청 URL : `[http://www.localhost.com:3000/users/login](http://www.localhost.com:3000/users/login)`
          - path : `/users/login`
          - 명시하지 않으면 기본 `/` 설정
          - 특징
            - 설정된 path를 전부 만족하는 경우 요청하는 path가 추가로 더 존재해도 쿠키를 서버에 전송할 수 있다.
              - path : `/users` , 요청 세부 경로 : `/users/login` 인 경우 쿠키 전송 가능
              - 요청 세부 경로 : `/user/login` 인 경우 쿠키 전송 불가능
        - **MaxAge or Expires** - 쿠키 유효 기간
          - MaxAge : 앞으로 몇 초 동안 쿠키가 유효한지 설정
          - Expires : MaxAge와 비슷하지만 언제까지 유효한지 `Date` 지정 (클라이언트의 시간 기준)
          - 지정된 시간, 날짜 초과시 쿠키 자동 파괴
          - 두 옵션이 모두 지정되지 않는 경우 → 브라우저 탭을 닫아야 쿠키 제거 가능
        - **Secure** - 쿠키를 전송해야 할 때 사용하는 프로토콜에 따른 쿠키 전송 여부 결정
          - `true` - 'HTTPS' 프로토콜을 이용하여 통신하는 경우에만 쿠키를 전송할 수 있다.
        - **HttpOnly** - 자바스크립트에서 브라우저의 쿠키에 접근 여부 결정
          - `true` - 접근 불가
          - `false` (default) - 접근 가능 (XSS 공격에 취약함)
        - **SameSite** - Cross-Origin 요청을 받은 경우 요청에서 사용한 메소드와 해당 옵션의 조합으로 서버의 쿠키 전송 여부 결정
          - _Lax_ : Cross-Origin 요청이면 **GET 메소드에 대해서만 쿠키 전송**
          - _Strict_ : Cross-Origin이 아닌 **same-site** 인 경우에만 쿠키 전송
            - `same-site` : 요청을 보낸 Origin과 서버의 도메인이 같은 경우
          - None : 항상 쿠키 전송.
            - `Secure` 옵션 필수
    - 쿠키를 이용한 상태 유지
      - 서버는 클라이언트에 인증 정보를 담은 쿠키를 전송하고, 클라이언트는 전달받은 쿠키를 요청과 함께 전송하여 Stateless한 인터넷 연결을 Stateful하게 유지할 수 있다.
      - 하지만 기본적으로는 쿠키는 오랜 시간 동안 유지될 수 있고, 자바스크립트를 이용해서 쿠키에 접근할 수 있기 때문에 쿠키에 민감한 정보를 담는 것은 위험하다.

## CSRF

#

Web application Security : 개발자들이 웹사이트, 모바일 어플, 웹 API를 만들 때 해커들의 공격을 막기 위해서 보안은 필수 사항

- SQL Injection
- XSS
- CSRF (Cross Site Request Forgery)

  - 주소가 다른 사이트에서 요청을 조작한다.
    - 다른 사이트에서 유저가 보내는 요청을 조작한다.
      - 예) 이메일에 첨부된 링크를 누르면 내 은행계좌의 돈이 빠져나간다.
    - 해커가 직접 데이터에 접근할 수 없다.
      - 다른 오리진이기 때문에 response에 직접 접근할 수 없다.
  - CSRF 공격을 하기 위한 조건
    - 쿠키를 사용한 로그인
      - 유저가 로그인했을 때, 쿠키로 어떤 유저인지 알 수 있어야 한다.
    - 예측할 수 있는 요청/parameter를 가지고 있어야 한다.
      - request에 해커가 모를 수 있는 정보가 담겨있으면 안된다.
  - CSRF 공격하기

    1. 계좌이체에 사용되는 GET 요청
    2. 해커는 타 유저의 계좌를 해커의 계좌로 바꿔서 요청할 수 있다.
    3. 유저인척 브라우저 환경에서 GET 요청을 보내게 만든다.
    4. 해커는 악성링크를 타 유저가 클릭하게 만들어서 돈을 보내게 만든다.

    5. 비밀번호 변경에 사용되는 POST 요청 - body에 정보를 담아서 보내서 공격하기 더 힘들다.
    6. 해커가 웹사이트 하나 만들어서 document form을 작성해서 페이지가 로딩되는 순간 숨겨진 form들이 비밀번호를 바꾸는 요청을 보내게 된다.

  - CSRF 예방
    - CSRF 토큰 사용하기
      - 서버측에서 CSRF 공격에 보호하기 위한 문자열을 유저의 브라우저와 웹 앱에만 제공한다.
    - Same-site cookie 사용하기
      - 같은 도메인에서만 세션/쿠키를 사용할 수 있다.
